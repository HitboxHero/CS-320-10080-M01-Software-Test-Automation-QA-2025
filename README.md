# CS-320-10080-M01-Software-Test-Automation-Quality-Assurance-2025

## About
This repository is part of my ongoing CS portfolio. It showcases my work in software testing, automation, and quality assurance. Included are project artifacts and reflections demonstrating my ability to create unit tests, analyze software testing approaches, and apply effective testing strategies.

## Repository Contents

### Project 1 – Mobile Application Testing (Contact Service)
**Summary (What problem did it solve?):**  
This project focused on developing and verifying a contact management service. It ensured that user contact data could be securely created, updated, and deleted while adhering to strict field requirements like maximum character limits and null checks. The primary problem solved was ensuring accurate, reliable, and secure handling of user contact information.

**What I did particularly well:**  
I created thorough unit tests using JUnit to validate all requirements, including testing edge cases like null values and fields exceeding allowed lengths. The service structure followed clear separation of concerns, making it easier to manage and expand.

**Where could I enhance my code, and how would it help?:**  
Incorporating even more exception-handling tests could further strengthen the robustness of the system. Adding boundary tests for exactly 10 or 30 characters would reinforce the input validation logic.

**Which pieces were most challenging, and how did I overcome them?:**  
Making sure all field validations (length and null) were fully covered in tests required multiple iterations. Careful reading of the requirements and incremental testing helped ensure completeness.

**Tools and resources added to my network:**  
- JUnit 5 documentation  
- Eclipse Coverage Plugin  
- Peer feedback to review edge case handling  

**Skills transferable to other projects:**  
- Test-driven development (TDD) principles  
- Data validation logic  
- Exception handling patterns  

**How I made this project maintainable, readable, and adaptable:**  
I used consistent naming conventions, added clear inline comments, and modularized validation logic to promote easier updates.

---

### Project 2 – Summary and Reflections Report
**Summary (What problem did it solve?):**  
The report summarized my entire testing approach, highlighting my unit testing practices, code quality, efficiency, mindset, and understanding of software testing strategies. It demonstrated the importance of cautious, unbiased, and disciplined testing throughout development.

**What I did particularly well:**  
I connected each major testing technique back to real-world industry practices. I also clearly showed how test coverage reports were used to validate the sufficiency of my test suites.

**Where could I enhance my work, and how would it help?:**  
Providing visual examples like annotated screenshots of test coverage could make future reviews of the report more dynamic and easier to follow.

**Which pieces were most challenging, and how did I overcome them?:**  
Writing about mindset—especially bias and discipline—was difficult because it required honest self-reflection. Relating it to real experiences in Project One helped make it more meaningful.

**Tools and resources added to my network:**  
- Stack Overflow Developer Survey 2024 for industry insights  
- Test-Driven Development (TDD) methodologies from TestDriven.io  

**Skills transferable to other projects:**  
- Professional reflection and documentation  
- Connecting technical work with software quality theory  
- Citing industry best practices  

**How I made this report maintainable, readable, and adaptable:**  
Organized into clear sections with evidence-based examples from my Java code. Sources were cited in APA style to maintain academic integrity.

---

## Additional Reflections

### How can I ensure that my code, program, or software is functional and secure?
By implementing thorough unit tests for all requirements, validating all user inputs, handling exceptions gracefully, and conducting regular code reviews. Using code coverage tools ensures testing is deep, not just superficial.

### How do I interpret user needs and incorporate them into a program?
I carefully study the written requirements and trace them into unit tests and code structures. Every function, class, and update process must map back to a clear user need or expectation.

### How do I approach designing software?
I break down requirements into modular components that can be individually developed and tested. I write pseudocode when needed and think about validation, security, and maintainability from the beginning rather than bolting them on later.

---

## Collaborators
For this assignment, I have added my instructor **klewis-github** as a collaborator so they can review my portfolio work.

## Acknowledgments
Thanks to my instructor and classmates for their support and detailed feedback throughout the CS-320 course.

## Contact
For any questions or suggestions, please feel free to open an issue or contact me.
